---
title: '解码方法'
date: 2021-04-21 22:40:24
tags: [算法,C++]
published: true
hideInList: false
feature: 
isTop: false
---

LeetCode 每日一题，经典动态规划题

<!--more-->

好久不更新博客了，主要是因为难题做不出，简单的又没啥好发的。

## 题目描述

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

    'A' -> 1
    'B' -> 2
    ...
    'Z' -> 26

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

+ "AAJF" ，将消息分组为 (1 1 10 6)
+ "KJF" ，将消息分组为 (11 10 6)

注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 s ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

**示例 1：**

    输入：s = "12"
    输出：2
    解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

**示例 2：**

    输入：s = "226"
    输出：3
    解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

**示例 3：**

    输入：s = "0"
    输出：0
    解释：没有字符映射到以 0 开头的数字。
    含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
    由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。

**示例 4：**

    输入：s = "06"
    输出：0
    解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。

**提示：**

+ 1 <= s.length <= 100
+ s 只包含数字，并且可能包含前导零。

来源：力扣（LeetCode）
链接：[原题链接](https://leetcode-cn.com/problems/decode-ways)

## 解题

很显然是动态规划，如果暴搜则时间复杂度为O(2^n),显然不行。

因为26个字母的映射只能是一位数字，或二位数，

不难发现对于字符串 s 的某个位置 i 而言，我们只关心「位置 i 自己能否形成独立 item 」和「位置 i 能够与上一位置（i-1）能否形成 item」，而不关心 i-1 之前的位置。

条件转移方程：

![转移方程](../images\解码方法-动态规划-LeetCode每日一题\2021-04-21-224829.png)

**注意：**
由于题目存在前导零，而前导零属于无效 item。可以进行特判

## Code

时间复杂度：共有 n 个状态需要被转移。复杂度为 O(n)O(n)
空间复杂度：O(n)O(n)

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n=s.size();
        vector<int> f(n+1);
        f[0]=1;
        for(int i=1;i<=n;i++)
        {
            if(s[i-1]!='0') f[i]+=f[i-1];
            if(i>1 && s[i-2]!='0' && ( ((s[i-2]-'0')*10 + (s[i-1]-'0'))<=26 ) ) f[i]+=f[i-2];
        }
        return f[n];
    }
};
```
