---
title: '分组背包问题'
date: 2021-03-03 22:18:31
tags: [算法]
published: true
hideInList: false
feature: 
isTop: false
---

#### 问题描述

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是 v~ij~，价值是 w~ij~，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

<!--more-->

#### 输入格式

第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。

接下来有 N 组数据：

每组数据第一行有一个整数 S~i~，表示第 i 个物品组的物品数量；
每组数据接下来有 S~i~ 行，每行有两个整数 v~ij~,w~ij~，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；
输出格式
输出一个整数，表示最大价值。

#### 数据范围

0<N,V≤100
0<S~i~≤100
0<v~ij~,w~ij~≤100

#### 分析

分组背包把一组物品看作一个整体，然后利用01背包的做法，与01背包的唯一不同点是：分组背包在01的基础上加入一个循环，遍历了一下组内物品，取最大值

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

int f[105];
int main()
{
    int n, m, v[105][105], w[105][105], c[105];
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> c[i];
        for (int j = 0; j < c[i]; j++)
        {
            cin >> v[i][j] >> w[i][j];
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = m; j >= 0; j--)
        {
            for (int k = 0; k < c[i]; k++)
            {
                if (v[i][k] <= j)
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[m];
    return 0;
}
```
