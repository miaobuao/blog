---
title: '棋盘挑战_N皇后问题'
date: 2021-03-08 12:30:35
tags: [算法,C++]
published: true
hideInList: false
feature: 
isTop: false
---

DFS基础题

<!--more-->

## 题目

给定一个 N×N 的棋盘，请你在上面放置 N 个棋子，要求满足：

每行每列都恰好有一个棋子
每条对角线上都最多只能有一个棋子

```txt
    1   2   3   4   5   6
  -------------------------
1 |   | O |   |   |   |   |
  -------------------------
2 |   |   |   | O |   |   |
  -------------------------
3 |   |   |   |   |   | O |
  -------------------------
4 | O |   |   |   |   |   |
  -------------------------
5 |   |   | O |   |   |   |
  -------------------------
6 |   |   |   |   | O |   |
  -------------------------
  ```

上图给出了当 N=6 时的一种解决方案，该方案可用序列 2 4 6 1 3 5 来描述，该序列按顺序给出了从第一行到第六行，每一行摆放的棋子所在的列的位置。

请你编写一个程序，给定一个 N×N 的棋盘以及 N 个棋子，请你找出所有满足上述条件的棋子放置方案。

输入格式
共一行，一个整数 N。

输出格式
共四行，前三行每行输出一个整数序列，用来描述一种可行放置方案，序列中的第 i 个数表示第 i 行的棋子应该摆放的列的位置。

这三行描述的方案应该是整数序列字典序排在第一、第二、第三的方案。

第四行输出一个整数，表示可行放置方案的总数。

数据范围
6 ≤ N ≤ 13

输入样例：
>6

输出样例：
>2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4

## 思路

数据范围不大，所以可以用暴搜来做，层层递归，需要注意的是，每行每列，以及正反两条倾斜角为45°的对角线上只能有一颗棋子

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, ans = 0;
bool dg[15 * 15], udg[15 * 15], col[15];
int path[15];

void dfs(int x)
{
    if (x > n)
    {
        ans++;
        if (ans <= 3)
        {
            for (int i = 1; i <= n; i++)
                cout << path[i] << " ";
            cout << endl;
        }
        return;
    }
    else
    {
        for (int i = 1; i <= n; i++)
        {
            if (!col[i] and !dg[x + i] and !udg[x - i + n])
            {
                path[x] = i;
                col[i] = dg[x + i] = udg[x - i + n] = true;
                dfs(x + 1);
                col[i] = dg[x + i] = udg[x - i + n] = false;
                path[x] = 0;
            }
        }
    }
}

int main()
{
    cin >> n;
    dfs(1);
    cout << ans;
    return 0;
}
```